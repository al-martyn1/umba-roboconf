# Правила

Все правила программы описываются в виде 
[S-выражений](https://ru.wikipedia.org/wiki/S-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5).
Когда вы пишете или изучаете правила программы, вам может показаться, что вы пишете/читаете программу 
на языке Лисп. И вы будете недалеки от истины.

При первоначальном разборе проверяется только базовая корректность синтаксиса. Полностью корректность 
правил проверяется при извлечении правил при работе подсистем, использующих эти правила.


## Шаблоны правил

Правила извлекаются по шаблонам, которые формализуют конкретные правила. Данные шаблоны представляют 
собой что-то типа DSL (Domain Specific Language - предметно-ориентированный язык). Вначале будет описан
формат формат шаблонов приавил, затем существующие правила будут описываться в виде выражений на этом DSL.

Система шаблонов правил в существующем виде сформировалась по историческим причинам. Изначально парсер
`S-выражений` был простым и предназначался для разбора нетлистов в формате P-CAD - списков компонентов
и соединений между ними. По мере развития программы было решено не зашивать правила обработки в коде,
а выносить их в текстовый конфигурационный файл, который может дополнять пользователь. Под рукой
был парсер `S-выражений`, и было решено использовать его также и для конфигурационных файлов.

При дальнейшем развитии программы выражения в конфигурационных файлах стали получаться всё сложнее, и 
ручной их разбор стал занимать много кода. С другой сотроны, было написано уже достаточно много кода,
и переходить на какие-либо генераторы грамматик означало бы переделку уже существующей эко-системы,
и было принято паллиативное решение частично формализовать разбор выражений в рамках существующей кодовой базы.


### Формат описания правил

#// parse.h:735 - readListByTemplate


#### Шаблонные атомы

Атомы могут быть следующими:

 - **L** - список значений;
 - **I** - вложенный список выражений;
 - **V** - значение;
 - **S** - что-то не до конца определенное, но соответствующее базовому синтаксису
           [S-выражений](https://ru.wikipedia.org/wiki/S-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5);
 - **A** - значение или список значений;
 - **M** - отображение значений (map) - представляется как последовательность двух-элементных списков, 
           каждый из которых представляет из себя пару `ключ`->`значение`.
 - **T** - токен;
#// - **;** - разделитель элементов списка атомов.

Примеры использования атомов будут приведены в описании атома `T`, после описаний остальных атомов.



#### Модификаторы атомов

Существуют следующие модификаторы атомов:

 - **+** - один или больше элементов;
 - **?** - один элемент или ни одного;
 - __*__ - любое количество элементов;
 - **_** - допустимо пустое значение;
 - **i** - регистр токенов игнорируется;
 - **s** - токены задаются с учётом регистра;
 - **#** - число - минимальное число элементов, `T3i` - минимум три токена без учета регистра;
 - **!** - нормальный останов разбора (без генерации ошибки) - дальнейший разбор будет производится 
           другими, детализирующими правилами. Это сделано для упрощения DSL, чтобы не вводить рекурсивные правила 
           и не усложнять разбор DSL.
 - **$** - остановка только в конце строки.

Выше перечисленные все возможные модификаторы атомов. Не все атомы поддерживают полностью данное множество модификаторов. 
Для каждого атома список поддерживаемых им атомов будет указываться явно, но уже без детального описания модификаторов.


#### Списки значений L

Атом списка `L` не поддерживает никаких модификаторов.


#### Значения V

Атом значения `V` поддерживает следующие модификаторы: `_`, `?`, `$`, `!`.

Значения могут быть заключены в кавычки, но кавычки не обязательны. Если значение содержит пробел, то оно должно быть 
заключено в кавычки. Кавычка внутри значения допустима и не требует экранирования, окончанием закавыченного значения
является кавычка и следующий за ней пробел. Никаких способов экранирования кавычек не предусмотрено.
Кавычка и следующий за ней пробел внутри значения не допустимы, но такие последовательности крайне маловероятно
могут понадобится в пользовательских правилах. Если понадобятся, будем думать.


#### S-атомы

Атомы `S` обозначают точно неопределённое на текущем уровне разбора, но корректное 
[S-выражение](https://ru.wikipedia.org/wiki/S-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5).

После атома `S` может следовать модификатор `'` (одиночная кавычка), который обозначает, что не требуется
раскавычивание (unquoting).


#### Значение или список значений A

Атом значения или списка значений `A` поддерживает следующие модификаторы: `_`, `+`, `$`.

#// После атома `A` может следовать 
#// модификатор `'` (одиночная кавычка), который обозначает, что не требуется раскавычивание (unquoting); 
#// модификатор `0` - обозначает допустимость пустого значения;
#// модификатор `*` - обозначает допустимость отсутствия значений;


#// parse.h:996

#### Вложенный список I

Атом списка `I` поддерживает следующие модификаторы: `_`, `+`.


#### Отображение значений (map) M

Атом отображений значений `M` поддерживает следующие модификаторы: `s`, `i`, `#`, `$`, `+`.
Пердставляет из себя список пар


#### vectorVector E

vectorVector???


#### Токены T

Атом токена `T` поддерживает следующие модификаторы: `s`, `i`, `!`.

Пример шаблона:
```
Ti!:componentclass;M1$:set,assembly,match,matchTo
```

В данном примере ожидается токен `componentclass` без учета регистра, разбор выражения остановится после окончания шаблона;
#// component_class.cpp:328 !!! Прогулятся отладчиком
Пример выражения, разбираемого данным шаблоном:
```
(componentClass (match compRef)(matchTo ".*RESISTOR-X2.*")(set RESISTOR)(assembly 2))
```


#// connections.h:1356
Пример шаблона:
```
Ti!:powerNet;Ti:ground,plus,minus;A+
```

Пример выражения, разбираемого данным шаблоном:
```
```


Пример шаблона:
```
list_conditional.h:135
Ti:conditional;V?!
list_conditional.h:165
Mi1$:-conditional,matchValue,matchCase,matchType,matchTo,-()
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
netlist.h:103
Ti:edif;V
netlist.h:125
Ti:edifVersion;V;V;V"
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
packages.cpp:233
Ti!:packageassign;M1+:designator,netlist,compare,package
packages.cpp:316
Ti!:package,packagealias
packages.cpp:339
V;Ti:numpins;V;A$
packages.cpp:408
V;A+$
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
roboconf_options.cpp:712
Ti!:keepGroup,forceGroup,forceUngroup;V_?;I
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```

Пример шаблона:
```
```

Пример выражения, разбираемого данным шаблоном:
```
```




```
// Пока хз, что это, надо вспоминать

            case ':':
            case ';':
                          flags |= (readedNumItemsVal&ExpressionParsingRuleFlags::number_mask) | ExpressionParsingRuleFlags::number_flag;

            case '+': flags |= ExpressionParsingRuleFlags::one_more_item_flag;

            case '?': flags |= ExpressionParsingRuleFlags::optional_item_flag;

            case '*': flags |= ExpressionParsingRuleFlags::any_number_items_flag;

            case '_': flags |= ExpressionParsingRuleFlags::empty_allowed_flag;

            case 'i': flags |= ExpressionParsingRuleFlags::icase_flag;

            case 's': flags &= ~ExpressionParsingRuleFlags::icase_flag;

            case '!': flags |= ExpressionParsingRuleFlags::good_stop_flag;

            case '$': flags |= ExpressionParsingRuleFlags::stops_on_eol_only;

            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                      if (readedNumber)
                          throw std::runtime_error("Expression parsing template - number taken multiple times");
                      readingNumber = true;

                      readedNumItemsVal *= 10;
                      readedNumItemsVal += (unsigned)(*pFlags-'0');
                      break;

```

#// I inner list
#// _+


#// M
#// si#$+


#// E

#// parse.h:1974
#// ListSimpleXPath
#// enum class AxisType
#// {
#//     child                  = 0,
#//     descendant_or_child    = 1,
#// };
#// 
#// parse.h:2040
#// parseQuery
#// 
#// parse.h:2083
#// collectCandidates  [/]path/to|*|alter|/list
#// 
#// parse.h:2104
#// executeQuery


ROBOCONF_PARSE_READ_LIST_BY_TEMPLATE( "Ti!:componentclass;M1$:set,assembly,match,matchTo"


